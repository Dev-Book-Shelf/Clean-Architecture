# 04장 구조적 프로그래밍

데이크스트라는 1952년 21살의 나이로 네덜란드 최초의 프로그래머로서 암스테르담의 수학센터에 취업한다.  
프로그래머로 일한 지 3년이 지났을 때, 프로그래밍에 대한 지적 도전이 이론 물리에 대한 지적 도전보다 더 큰 의미가 있다는 결론을 내렸다.  
그래서 장기적인 진로로 프로그래밍을 선택한다.

하지만 당시 네덜란드에서는 '프로그래머'라는 직업 자체를 인정하지 않았다. 이전에 없던 직업이라

## 증명

데이크스트라가 초기에 인식한 문제는 프로그래밍은 어렵고, 프로그래머는 프로그래밍을 잘하지 못한다는 사실이었다.  
프로그램은 단순해보이더라도, 작은 세부사항이라도 간과하면 결국엔 예상 외의 방식으로 실패하곤 했다.

데이크스트라는 증명이라는 수학적 원리를 이용해 이 문제를 해결하려 했다.  
그의 비전은 공리, 정리, 따름정리, 보조정리로 구성되는 유클리드 계층 구조를 만드는 것이었다.

데이크스트라는 이 연구를 진행하면서 goto 문장이 모듈을 더 작은 단위로 재귀적으로 분해하는 과정에 방해가 된다는 사실을 발견했다.  
모듈을 분해할 수 없다면, 합리적으로 증명할 때 필수 기법인 분할 정복 접근법을 사용할 수 없게 된다.

goto 대신 if/then/else와 do/while과 같은 단순한 제어 구조만 사용하면 증명 가능한 단위까지 재귀적으로 세분화 하는 것이 가능해보였다.

또한 이러한 제어 구조는 순차 실행과 결합했을 때 특별하다는 사실을 깨달았다.  
모듈을 증명 가능하게 하는 바로 그 제어 구조가 모든 프로그램을 만들 수 있는 제어 구조의 최소 집합과 동일하다는 사실이었다.

구조적 프로그래밍은 이렇게 탄생했다.

데이크스트라는 순차 구문, 분기, 반복의 올바름을 수학적으로 증명했고, 유클리드 계층구조를 만들 수 있을 거라는 생각이 이루어질 듯 보였다.

## 해로운 성명서

1968년 데이크스트라는 CACM 학술지 편집자에게 해당 내용이 담긴 편지를 썼고, 3월호에 실렸다.  
데이크스트라의 견해에 극도로 부정적인 반응도 있는 반면, 강력하게 지지하는 의견도 있었다.

10년 이상 분쟁이 지속되다 결국 데이크스트라가 승리했다.  
컴퓨터 언어가 진화하면서 goto 문장은 마침내 결국 사라졌다.

## 기능적 분해

구조적 프로그래밍을 통해 모듈을 증명 가능한 더 작은 단위로 재귀적으로 분해할 수 있게 되었다.  
즉, 거대한 문제 기술서를 받더라도 문제를 고수준의 기능들로 분해할 수 있다.

이를 토대로 구조적 분석(structured analysis)이나 구조적 설계(structured design)와 같은 기법이 1970년대 후반에서 1980년대에 걸쳐 인기를 끌었다.

## 엄밀한 증명은 없었다

하지만 끝내 프로그램 관점에서 정리에 대한 유클리드 계층구조는 만들어지지 않았다.

다행히도 무언가가 올바른지를 입증할 때 사용하는 전략에 유클리드 방식 같이 엄밀한 수학적 증명만이 있는 것은 아니다.  
과학적 방법이 있다.

## 과학이 구출하다

과학은 근본적으로 수학과 다른데, $F=ma$ 또는 $F=Gm_1m_2/r^2$ 같은 법칙이 수학적으로 옳다고 증명할 수 없다.  
이 법칙들을 시연할 수 있고, 정밀하게 측정할 수는 있지만

과학은 서술된 내용이 사실임을 증명하는 방식이 아니라 서술이 틀렸음을 증명하는 방식으로 동작한다.

## 테스트

데이크스트라는 "테스트는 버그가 있음을 보여줄 뿐, 버그가 없음을 보여줄 수는 없다"라고 말한 적이 있다.

테스트에 충분한 노력을 들였다면 테스트가 보장할 수 있는 것은 프로그램이 목표에 부합할 만큼은 충분히 참이라고 여길 수 있게 해주는 것이 전부다.

소프트웨어 개발이 수학적인 구조를 다루는 듯 보이더라도, 소프트웨어 개발은 수학적인 시도가 아니라는 사실이다.  
최선을 다하더라도 올바르지 않음을 증명하는 데 실패함으로써 올바름을 보여주기 때문이다.

## 결론

구조적 프로그래밍이 오늘날까지 가치 있는 이유는 프로그래밍에서 반증 가능한 단위를 만들어 낼 수 있는 능력 때문이다.  
또한 현대적 언어가 아무런 제약 없는 goto 문장을 지원하지 않는 이유이기도 하다.

아키텍처 관점에서는 기능적 분해를 최고의 실천법 중 하나로 여긴다.  
소프트웨어 아키텍트는 모듈, 컴포넌트, 서비스가 쉽게 반증 가능하도록 만들기 위해 분주히 노력해야 한다.
