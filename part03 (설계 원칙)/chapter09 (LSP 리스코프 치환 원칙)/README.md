# 09장 LSP: 리스코프 치환원칙

1988년 바바라 리스코프(Barbara Liskov)는 하위 타입(subtype)을 이렇게 정의했다.

> 여기서 필요한 것은 다음과 같은 치환(substitution) 원칙이다. S 타입의 객체 o1 각각에 대응하는 T 타입 객체 o2가 있고, T 타입을 이용해서 정의한 모든 프로그램 P에서 o2자리에 o1을 치환하더라도 P의 행위가 변하지 않는다면 S는 T의 하위 타입이다.

## 상속을 사용하도록 가이드하기

License라는 클래스가 있다고 해보자.  
이 클래스는 calcFee()라는 메서드를 가지며, Billing 애플리케이션에서 이 메서드를 호출한다.

License에는 PersonalLicense와 BusinessLicense라는 두 가지 하위 타입이 존재한다.  
이 두 하위 타입은 서로 다른 알고리즘을 이용해서 라이선스 비용을 계산한다.

이 설계는 LSP를 준수하는데, Billing 애플리케이션의 행위가 License 하위 타입 중 무엇을 사용하는지에 전혀 의존하지 않기 때문이다. 이들 하위 타입은 모두 License 타입을 치환할 수 있다.

## 정사각형/직사각형 문제

LSP를 위반한느 전형적인 문제로는 정사각형/직사각형 문제가 있다..

Square는 Rectangle의 하위 타입으로는 적절하지 않은데, Rectangle의 높이와 너비는 독립적으로 변경될 수 있는 반면, Square의 높이와 너비는 항상 함께 변경되기 때문이다.

## LSP와 아키텍처

객체 지향 등장 초창기에 LSP는 상속을 사용하는 가이드 정도로 생각되었는데, 시간이 지나면서 더 광범위한 소프트웨어 설계 원칙으로 변모해왔다.

## LSP 위배 사례

택시 파견 서비스를 통합하는 애플리케이션을 만들고 있다고 해보자.

고객은 어느 택시 업체인지 신경쓰지 않고 적합한 택시를 찾는다.

고객이 택시를 결정하면, 시스템은 기사의 DB 레코드를 읽어 URI 정보를 얻은 다음, 기사가 속한 택시 회사 API 서버에 REST 요청을 보낸다.

```
purplecab.com/driver/Bob
/pickupAddress/24 Maple St.
/pickupTime/153
/destination/ORD
```

같은 형식으로.

문제는 다양한 택시 업체에서 동일한 REST 인터페이스를 준수해야 하는데,  
다른 택시 업체인 애크미에서 destination을 dest로 축약해 사용해버리면

우리 회사의 시스템 아키텍처에는 무슨 일이 벌어질까

```Java
if (driver.getDispatchUri().startsWith("acme.com"))..........
```

아주 끔찍하다

아키텍트는 이 같은 버그로부터 시스템을 격리해야 한다.

URI를 키로 사용하는 설정용 데이터베이스를 이용하는 파견 명령 생성 모듈을 만들어야 할 수도 있다..

| URI      | Dispatch Format                                |
| -------- | ---------------------------------------------- |
| acme.com | /pickupAddress/%s/pickupTime/%s/dest/%s        |
| \*.\*    | /pickupAddress/%s/pickupTime/%s/destination/%s |

## 결론

LSP는 아키텍처 수준까지 확장할 수 있고, 반드시 확장해야만한다.

치환 가능성을 조금이라도 위배하면 시스템 아키텍처가 오염되어 상당량의 별도 메커니즘을 추가해야 할 수 있기 때문이다.
